
/*
  Test de réception
*/

// Define various ADC prescaler
const unsigned char PS_16 = (1 << ADPS2);
const unsigned char PS_32 = (1 << ADPS2) | (1 << ADPS0);
const unsigned char PS_64 = (1 << ADPS2) | (1 << ADPS1);
const unsigned char PS_128 = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);

int RC;
int tab_RC[2];
int deriv;
int moy;
boolean valBool,bitRC[8],start[3];
int iBitRc,iStart;
long tps1;
long tps2;
int Tech=400; //temps d'échantillonnage en µsecondes

int nbValId=4; //nbValId=TEmission/TechRC  nb de bit successif désignant une valeur ELLE VAUT 3 à 1200et400µs
int intermed; //Cette valeur est un compteur comptant le nombre de réaparission d'un bit
int tpsMaxi=100;  //Nombre maximal d'échantillon identique successif

void setup() 
{
  delay(1000);
  Serial.begin(115200);  //Config de l'usb a 115 200 bauds
  Serial.flush();
  tab_RC[0]=0;
  tab_RC[1]=0;
  Serial.println("Starting");
  
  
  // set up the ADC
  ADCSRA &= ~PS_128;  // remove bits set by Arduino library
  ADCSRA |= PS_16;
  
  iBitRc=0;
  iStart=0;
  intermed=0;

}

void loop()
{
  tps1=micros();
  RC=analogRead(0);
  //Décalage de la valeur dans le tab_RC
  tab_RC[0]=tab_RC[1];
  tab_RC[1]=RC;
  
  moy=tab_RC[1]+tab_RC[0];
  moy/=6;
  deriv=tab_RC[1]-tab_RC[0];
  
  if(deriv>moy && moy>1){
    valBool=1;
    intermed=1;
  /*  Serial.print("0 :");
    Serial.print(tab_RC[0], DEC);
    Serial.print(", 1 :");
    Serial.print(tab_RC[1], DEC);
    Serial.println(" Front montant");    */
  }
  else if(deriv<-moy && moy>1)
  {
    valBool=0;
    intermed=1;
 /* Serial.print("0 :");
    Serial.print(tab_RC[0], DEC);
    Serial.print(", 1 :");
    Serial.print(tab_RC[1], DEC);
    Serial.println(" Front descendant");*/
  }
  else
  {
    intermed++;//Incrémentation du compteur intermed
  }
  
  if(intermed>tpsMaxi)  //Reset si trop longtemps sans activité
  {
    intermed=0;
    valBool=0;
  }
  
  if(intermed%nbValId==0){  //Si meme val successive
    if(nbValId==4){  //detection démarrage
      start[iStart]=valBool;
      iStart=(iStart+1)%3;
      if(start[0]==1 && start[1]==0 && start[2]==1){  //Si le start est detecte
        nbValId-=2;        //Echantillon de 3 bits pour une valeur
        intermed=0;
      }
      if(iStart==0){
        start[0]=0;
        start[1]=0;
        start[2]=0;
      }
    }
    else{  //Detection code
    bitRC[iBitRc]=valBool;
  //  Serial.print(" ");
    //Serial.println(valBool);
    iBitRc=(iBitRc+1)%7;
      if(iBitRc==0){
        nbValId+=2;
        for(int c=0;c<7;c++){
  //        Serial.print(bitRC[c]);
        }
  //      Serial.println(bitRC[7]);
      }
    }
  }
  

  tps2=micros();
  Serial.println(valBool);
  Serial.println(tps2-tps1);
  while(tps2-tps1<Tech)  //Attente prochain cycles d'échantillonnage
  {
     tps2=micros();
  }


//  delayMicroseconds(5);
}

